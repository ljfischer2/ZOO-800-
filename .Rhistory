# Do n_boot resamples WITH replacement; compute the mean each time
# replicate(...) returns a numeric vector of bootstrap means
means <- replicate(n_boot, mean(sample(x, size = sample_size, replace = TRUE)))
# Return the average of those bootstrap means (a stable estimate)
mean(means)
}
t_serial <- system.time({                   # time the whole serial run
res_serial <- lapply(                     # loop over species in the main R process
species,                                # input: vector of species names
boot_mean,                              # function to apply
n_boot = 500,                           # number of bootstrap resamples per species
sample_size = 100                       # bootstrap sample size
)
})
n_cores <- max(1, detectCores() - 1)        # use all but one core (be nice to your laptop)
cl <- makeCluster(n_cores)                  # start worker processes
clusterSetRNGStream(cl, iseed = 123)        # make random numbers reproducible across workers
# Send needed objects to workers (function + data + species vector)
clusterExport(cl, varlist = c("fish", "boot_mean", "species"), envir = environment())
t_parallel <- system.time({                 # time the parallel run
res_parallel <- parLapply(                # same API as lapply(), but across workers
cl,                                     # the cluster
species,                                # each worker gets one species (or more)
boot_mean,                              # function to run
n_boot = 500,                           # same bootstrap settings as serial
sample_size = 100
)
})
stopCluster(cl)                             # always stop the cluster when done
# Extract elapsed (wall) time and compute speedup = serial / parallel
elapsed_serial   <- unname(t_serial["elapsed"])
elapsed_parallel <- unname(t_parallel["elapsed"])
speedup <- elapsed_serial / elapsed_parallel
cat("Serial elapsed (s):   ", round(elapsed_serial, 3), "\n")
cat("Parallel elapsed (s): ", round(elapsed_parallel, 3), " using ", n_cores, " cores\n", sep = "")
cat("Speedup:               ", round(speedup, 2), "x\n", sep = "")
rm(list = ls())
oot_mean <- function(species_name, n_boot = 500, sample_size = 100) {
# Pull the Length_cm vector for just this species
x <- fish$Length_cm[fish$Species == species_name]
# Do n_boot resamples WITH replacement; compute the mean each time
# replicate(...) returns a numeric vector of bootstrap means
means <- replicate(n_boot, mean(sample(x, size = sample_size, replace = TRUE)))
# Return the average of those bootstrap means (a stable estimate)
mean(means)
}
t_serial <- system.time({                   # time the whole serial run
res_serial <- lapply(                     # loop over species in the main R process
species,                                # input: vector of species names
boot_mean,                              # function to apply
n_boot = 1000,                           # number of bootstrap resamples per species
sample_size = 200                       # bootstrap sample size
)
})
boot_mean <- function(species_name, n_boot = 500, sample_size = 100) {
# Pull the Length_cm vector for just this species
x <- fish$Length_cm[fish$Species == species_name]
# Do n_boot resamples WITH replacement; compute the mean each time
# replicate(...) returns a numeric vector of bootstrap means
means <- replicate(n_boot, mean(sample(x, size = sample_size, replace = TRUE)))
# Return the average of those bootstrap means (a stable estimate)
mean(means)
}
t_serial <- system.time({                   # time the whole serial run
res_serial <- lapply(                     # loop over species in the main R process
species,                                # input: vector of species names
boot_mean,                              # function to apply
n_boot = 1000,                           # number of bootstrap resamples per species
sample_size = 200                       # bootstrap sample size
)
})
library(parallel)                          # built-in; no install needed
fish <- read.csv("Data/fish_bootstrap_parallel_computing.csv")     # adjust path if needed
species <- unique(fish$Species)            # list of species we'll loop over
boot_mean <- function(species_name, n_boot = 500, sample_size = 100) {
# Pull the Length_cm vector for just this species
x <- fish$Length_cm[fish$Species == species_name]
# Do n_boot resamples WITH replacement; compute the mean each time
# replicate(...) returns a numeric vector of bootstrap means
means <- replicate(n_boot, mean(sample(x, size = sample_size, replace = TRUE)))
# Return the average of those bootstrap means (a stable estimate)
mean(means)
}
t_serial <- system.time({                   # time the whole serial run
res_serial <- lapply(                     # loop over species in the main R process
species,                                # input: vector of species names
boot_mean,                              # function to apply
n_boot = 1000,                           # number of bootstrap resamples per species
sample_size = 200                       # bootstrap sample size
)
})
n_cores <- max(1, detectCores() - 1)        # use all but one core (be nice to your laptop)
cl <- makeCluster(n_cores)                  # start worker processes
clusterSetRNGStream(cl, iseed = 123)        # make random numbers reproducible across workers
# Send needed objects to workers (function + data + species vector)
clusterExport(cl, varlist = c("fish", "boot_mean", "species"), envir = environment())
t_parallel <- system.time({                 # time the parallel run
res_parallel <- parLapply(                # same API as lapply(), but across workers
cl,                                     # the cluster
species,                                # each worker gets one species (or more)
boot_mean,                              # function to run
n_boot = 10000,                           # same bootstrap settings as serial
sample_size = 200
)
})
stopCluster(cl)                             # always stop the cluster when done
# Extract elapsed (wall) time and compute speedup = serial / parallel
elapsed_serial   <- unname(t_serial["elapsed"])
elapsed_parallel <- unname(t_parallel["elapsed"])
t_serial <- system.time({                   # time the whole serial run
res_serial <- lapply(                     # loop over species in the main R process
species,                                # input: vector of species names
boot_mean,                              # function to apply
n_boot = 10000,                           # number of bootstrap resamples per species
sample_size = 200                       # bootstrap sample size
)
})
n_cores <- max(1, detectCores() - 1)        # use all but one core (be nice to your laptop)
cl <- makeCluster(n_cores)                  # start worker processes
clusterSetRNGStream(cl, iseed = 123)        # make random numbers reproducible across workers
# Send needed objects to workers (function + data + species vector)
clusterExport(cl, varlist = c("fish", "boot_mean", "species"), envir = environment())
t_parallel <- system.time({                 # time the parallel run
res_parallel <- parLapply(                # same API as lapply(), but across workers
cl,                                     # the cluster
species,                                # each worker gets one species (or more)
boot_mean,                              # function to run
n_boot = 10000,                           # same bootstrap settings as serial
sample_size = 200
)
})
stopCluster(cl)                             # always stop the cluster when done
# Extract elapsed (wall) time and compute speedup = serial / parallel
elapsed_serial   <- unname(t_serial["elapsed"])
elapsed_parallel <- unname(t_parallel["elapsed"])
speedup <- elapsed_serial / elapsed_parallel
cat("Serial elapsed (s):   ", round(elapsed_serial, 3), "\n")
cat("Parallel elapsed (s): ", round(elapsed_parallel, 3), " using ", n_cores, " cores\n", sep = "")
cat("Speedup:               ", round(speedup, 2), "x\n", sep = "")
library(readxl)
library(writexl)
library(tidyverse)
#library(openxlsx)
#Problem 1######
fishcsv <- read.csv("Data/fish.csv")
head(fishcsv)
fishxl<- read_excel('Data/fish.xlsx')
head(fishxl)
fishrds <- readRDS('Data/fish.rds')
head(fishrds)
#Problem 2######
#Once we have read all of the files, we need to rewrite them and export them
# out of R.  If I am honest, my naming convention here was terrible.
# But whatever, it should be alright.
write.csv(x = fishcsv, 'Data/Output/fishcsvout.csv' )
write_xlsx(fishcsv, 'Data/Output/fishcsvout.xlsx')
saveRDS(fishcsv, 'Data/Output/fishcsvout.rds')
#The comment line below is for the package 'openxlsx'.  Not necessary
#saveWorkbook(fishcsv, 'Data/Output/fishcsvout.csv')
file.info('Data/Output/fishcsvout.csv',
'Data/Output/fishcsvout.xlsx',
'Data/Output/fishcsvout.rds')
#I think there is something odd about the sizes listed in R compared to
# what is reported in the actual file viewer, but based on this I would
# think the .csv file is the most convenient in general, while the .rds file
# is the most convenient for sending, as long as the receiver has R.
# Otherwise I would likely still elect to use the .csv file. For File
# storage, a .rds format would be the best option.
#.csv size: ~14 kb (~11 kb in file viewer)
#.rds size: ~3 kb
#.xlsx size: ~14 kb (~18 kb in file viewer)
library(palmerpenguins)
summary(penguins)
ggplot(data = penguins, aes(x = flipper_length_mm, y = body_mass_g)) +
geom_point()
plot2 <- ggplot(data = penguins, aes(x = flipper_length_mm,
y = body_mass_g,
color = species)) +
geom_point()
plot2
plot3 <- plot2 + facet_wrap(~species, ncol = 3)
plot3
#facet_grid works well for two variables you want to illustrate
plot4 <- plot3 + geom_smooth(method = 'lm')
plot4
plot5
#other plots
plot5 <- ggplot(data = penguins, aes(x = species,
y = body_mass_g)) +
geom_boxplot()
plot5
#other plots
plot5 <- ggplot(data = penguins, aes(x = species,
y = body_mass_g)) +
geom_boxplot()
plot5
plot6 <- ggplot(data = penguins, aes(x = species,
y = body_mass_g)) +
geom_violin() + geom_jitter()
plot6
#changing colors in ggplot
plot9 <- plot2 + scale_color_brewer(palette = "Set2")
plot9
#In-class code that would be journal-ready
peng <- penguins
View(peng)
ggplot(penguins, aes(x = sex, y = flipper_length_mm, color = sex)) +
geom_boxplot()
peng_noNA <- peng[peng$sex !== NA]
peng_noNA <- peng[peng$sex != NA]
peng_noNA <- peng[peng$sex == "male" | peng$sex == 'female']
peng_noNA <- peng[peng$sex == "male" | peng$sex == 'female']
peng_noNA <- peng[,peng$sex == "male" | peng$sex == 'female']
peng_noNA <- peng[peng$sex == "male" | peng$sex == 'female',]
View(peng_noNA)
ggplot(penguins, aes(x = sex, y = flipper_length_mm, color = sex)) +
geom_boxplot()
peng_noNA <- peng[, peng$sex == "male" | peng$sex == 'female']
#In-class code that would be journal-ready
peng <- penguins
peng_noNA <- peng %>%
filter(sex %in% c('male', 'female'))
ggplot(penguins, aes(x = sex, y = flipper_length_mm, color = sex)) +
geom_boxplot()
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, color = sex)) +
geom_boxplot()
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill() = sex)) +
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_boxplot()
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_violin() +
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_violin() +
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_violin() +
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_violin() +
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_violin()
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_violin() +
scale_color_brewer("Dark3")
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_violin() +
scale_color_brewer(pallette = "Dark2")
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_violin() +
scale_color_brewer(palette = "Dark2")
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_violin() +
scale_color_brewer(palette = "Dark2") +
facet_wrap(~species)
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm)) +
geom_violin() +
scale_color_brewer(palette = "Dark2") +
facet_wrap(~species)
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm)) +
geom_violin() +
scale_fill_brewer(palette = "Dark2") +
facet_wrap(~species)
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_violin() +
scale_fill_brewer(palette = "Dark2") +
facet_wrap(~species)
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_violin() +
scale_fill_brewer(palette = "Dark2") +
geom_point()
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_violin() +
scale_fill_brewer(palette = "Dark2") +
geom_point() +
geom_jitter() +
facet_wrap(~species)
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_violin() +
scale_fill_brewer(palette = "Dark2") +
geom_point(size = 1) +
geom_jitter() +
facet_wrap(~species)
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_violin() +
scale_fill_brewer(palette = "Dark2") +
geom_jitter() +
facet_wrap(~species)
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_violin() +
scale_fill_brewer(palette = "Dark2") +
geom_jitter(size = 1) +
facet_wrap(~species)
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_violin() +
scale_fill_brewer(palette = "Dark2") +
geom_jitter(size = 1, width = 0.5,
alpha = 0.5) +
facet_wrap(~species)
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_violin() +
scale_fill_brewer(palette = "Dark2") +
geom_jitter(size = 1, width = 0.2,
alpha = 0.5) +
facet_wrap(~species)
library(rgl)
install.packages('rgl')
library(rgl)
library(rgl)
plot3d(
x=data$`Sepal.Length`, y=data$`Sepal.Width`, z=data$`Petal.Length`,
col = data$color,
type = 's',
radius = .1,
xlab="Sepal Length", ylab="Sepal Width", zlab="Petal Length")
library(rgl)
library('rgl')
library(rgl)
install.packages('xfun')
library(xfun)
library(rgl)
plot3d(
x=data$`Sepal.Length`, y=data$`Sepal.Width`, z=data$`Petal.Length`,
col = data$color,
type = 's',
radius = .1,
xlab="Sepal Length", ylab="Sepal Width", zlab="Petal Length")
mycolors <- c('royalblue1', 'forestgreen', 'darkred')
peng_noNA$color <- mycolors[ as.numeric(data$Species) ]
plot3d(
x=peng_noNA$flipper_length_mm,
y=peng_noNA$body_mass_g,
z=peng_noNA$bill_depth_mm,
col = mycolors,
type = 's',
radius = .1,
xlab="Sepal Length", ylab="Sepal Width", zlab="Petal Length")
peng_noNA <- peng %>%
filter(sex %in% c('male', 'female'))
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_violin() +
scale_fill_brewer(palette = "Dark2") +
geom_jitter(size = 1, width = 0.2,
alpha = 0.5) +
facet_wrap(~species)
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_violin() +
scale_fill_brewer(palette = "Dark2") +
geom_jitter(size = 1, width = 0.2,
alpha = 0.5) +
facet_wrap(~species) +
labs(x = 'Sex',
y = 'Flipper Length(mm)',
fill = 'sex') +
theme(axis.title = element_text(size = 14),
axis.text = element_text(size = 12))
g
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_violin() +
scale_fill_brewer(palette = "Dark2") +
geom_jitter(size = 1, width = 0.2,
alpha = 0.5) +
facet_wrap(~species) +
labs(x = 'Sex',
y = 'Flipper Length(mm)',
fill = 'sex') +
theme(plot.title = element_text(size = 18),
axis.title = element_text(size = 14),
axis.text = element_text(size = 12))
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_violin() +
scale_fill_brewer(palette = "Dark2") +
geom_jitter(size = 1, width = 0.2,
alpha = 0.5) +
facet_wrap(~species) +
labs(x = 'Sex',
y = 'Flipper Length(mm)',
fill = 'sex') +
theme(plot.subtitle = element_text(size = 14),
axis.title = element_text(size = 14),
axis.text = element_text(size = 12))
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_violin() +
scale_fill_brewer(palette = "Dark2") +
geom_jitter(size = 1, width = 0.2,
alpha = 0.5) +
facet_wrap(~species) +
labs(x = 'Sex',
y = 'Flipper Length(mm)',
fill = 'sex') +
theme(
axis.title = element_text(size = 16),
axis.text = element_text(size = 14))
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_violin() +
scale_fill_brewer(palette = "Dark2") +
geom_jitter(size = 1, width = 0.2,
alpha = 0.5) +
facet_wrap(~species) +
labs(x = 'Sex',
y = 'Flipper Length(mm)',
fill = 'sex') +
theme(
axis.title = element_text(size = 16),
axis.text = element_text(size = 14)) +
theme_dark()
ggplot(peng_noNA, aes(x = sex, y = flipper_length_mm, fill = sex)) +
geom_violin() +
scale_fill_brewer(palette = "Dark2") +
geom_jitter(size = 1, width = 0.2,
alpha = 0.5) +
facet_wrap(~species) +
labs(x = 'Sex',
y = 'Flipper Length(mm)',
fill = 'sex') +
theme(
axis.title = element_text(size = 16),
axis.text = element_text(size = 14)) +
theme_classic()
library(tidyverse)
library(dplyr)
library(magrittr)
library(ggplot2)
library(viridis)
##############
### SET-UP ###
##############
install.packages('magrittr','viridis',)
install.packages("magrittr", "viridis", )
library(tidyverse)
#library(dplyr)
library(magrittr)
#library(ggplot2)
library(viridis)
##############
### SET-UP ###
##############
install.packages('magrittr','viridis')
install.packages("magrittr", "viridis")
##############
### SET-UP ###
##############
install.packages('viridis')
library(tidyverse)
#library(dplyr)
library(magrittr)
#library(ggplot2)
library(viridis)
library(palmerpenguins)
# GUIDELINES #
# Turn-in: Upload .R file to canvas
# 1. Compares the average flipper length between male and female penguins of each species (visually, no need for stats)
# 2. Has informative and legible axes labels
# 3. Does not have the annoying gray ggplot background that reproduces poorly in print
penguins <- na.omit(penguins) # remove NAs from data to prevent appearance in ggplot grpahic
penguin_plot <- ggplot(penguins, aes(x = sex, y = flipper_length_mm, fill = species)) +
geom_violin(trim = FALSE) +
geom_jitter(alpha = 0.5) +
facet_wrap(~species, scales = "free") +
scale_fill_viridis_d(option = "plasma") +
labs(
x = "Sex",
y = "Flipper Length (mm)",
caption = "Figure 1. Comparison of flipper length of male and female penguins among three species. Data from palmerpenguins package in R.",
fill = "Species"
) +
theme_bw(base_size = 14) +
theme(axis.title.x = element_text(margin = margin(t = 20)),
axis.title.y = element_text(margin = margin(r = 20)),
plot.caption = element_text(hjust = 0.5, size = 10, face = "italic", margin = margin(t = 20)),
legend.position = "left")
penguin_plot
# load in required package
library(palmerpenguins)
# the data set is auomatically populated into the environment
# (much like functions from a package)
# you can store it as your own object if you like
View(penguins)
df = penguins
# function to convert body mass to categorical variable
convert_to_binary <- function(size, break.point) {
binary_variable <- ifelse(size > break.point, "large", "small") # if number is bigger than threshold, call it "large" otherwise call it "small"
return(binary_variable)
}
# create/format data that matches the arguments the function requires
# you can just provide the specific body size column as input data here,
# but see below where it can be useful to provide the entire data frame
size = penguins$body_mass_g
break.point = 4000
# see if it worked!
convert_to_binary(size = size,
break.point = break.point)
# create/format data that matches the arguments the function requires
# you can just provide the specific body size column as input data here,
# but see below where it can be useful to provide the entire data frame
size = penguins$body_mass_g
break.point = 4000
# see if it worked!
convert_to_binary(size = size,
break.point = break.point)
# function to convert body mass to categorical variable
# (dplyr solution for the tidyverse fans)
convert_to_discrete <- function(data, breaks, labels) {
require(dplyr)
categorized_data <- data %>%
mutate(
discrete_variable = case_when(     # case_when is useful for labeling based on conditional statements
body_mass_g < breaks[1] ~ labels[1],
body_mass_g >= breaks[1] & body_mass_g < breaks[2] ~ labels[2],
body_mass_g >= breaks[2] ~ labels[3]
)
)
print(categorized_data$discrete_variable)
}
library(tidyverse)
